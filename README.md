# spring-cloud-microservice4
# Mini banding system
## О проекте
### Микросервисная архитектура
### Технологии
* Spring Boot
* Spring Cloud
* PostrgreSQL
* RabbitMQ
* Docker

## Архитектура бизнес логики
Рассмотриваем только сервисы, которые выполняют бизнес-логику, и взаимосвязи между ними.
 <p align="center">
  <img src="https://i.ibb.co/2y8YdD8/Business-Logic-Architecture.png" width="600">
</p>

В данном проекте бизнес-логики включает в себя Account service, Bill service, Deposit service и их базы данных.

Сервис обработки депозитов никак не взаимодействует с базой данных аккаунтов или базой данных счетов. Он получает эту информацию с помощью HTTP-запросов, согласно протоколу REST, сервис посылает запрос Bill для получения счета. И он также посылает запрос сервису Account по протоколу REST, чтобы также получить счет.

Служба Notification будет отвечать за уведомления. Она подключается к сервису Deposit с помощью очереди сообщений RabbitMQ.

В Deposit поступает запрос на пополнение счета, он делает запрос к Bill, к Account и успешно веполняет пополнение.

Далее, из сервиса Deposit мы собираемся поместить сообщение в очередь RabbitMQ. RabbitMQ отправит это сообщение в сервис Notification, и в сервисе Notification мы получим сообщение о том, что был сделан депозит на какой-то email.

Ниже приведен сервис для отправки сообщений. Этот сервис взят из Gmail.



## Архитектура Spring Cloud

Рассмотрим схему приложения, включая инфраструктурные сервисы.
 <p align="center">
  <img src="https://i.ibb.co/2y8YdD8/Business-Logic-Architecture.png" width="600">
</p>

В данном проекте бизнес-логики включает в себя Account service, Bill service, Deposit service и их базы данных.

Сервис обработки депозитов никак не взаимодействует с базой данных аккаунтов или базой данных счетов. Он получает эту
информацию с помощью HTTP-запросов, согласно протоколу REST, сервис посылает запрос Bill для получения счета. И он также
посылает запрос сервису Account по протоколу REST, чтобы также получить счет.

Служба Notification будет отвечать за уведомления. Она подключается к сервису Deposit с помощью очереди сообщений
RabbitMQ.

В Deposit поступает запрос на пополнение счета, он делает запрос к Bill, к Account и успешно веполняет пополнение.

Далее, из сервиса Deposit мы собираемся поместить сообщение в очередь RabbitMQ. RabbitMQ отправит это сообщение в сервис
Notification, и в сервисе Notification мы получим сообщение о том, что был сделан депозит на какой-то email.

Ниже приведен сервис для отправки сообщений. Этот сервис взят из Gmail.

### Архитектура Spring Cloud

Рассмотрим схему приложения, включая инфраструктурные сервисы.
<p align="center">
  <img src="https://i.ibb.co/bLJxK3L/Architecture-Spring-Cloud.png" width="800">
</p>

Когда приложение запускается, Account вызовет Config (это вспомогательный сервис), чтобы он вернуть специальный
application.yml для Account. То же самое произойдет и с сервисами Deposit, Bill и Notification. Служба Config передает
нужные application.yml. Все настройки будет находиться в сервисе Config. При запуске все приложения будут обращаться к
службе Config.

Discovery предназначен для регистрации всех приложений (наших сервисов), и он всегда знает адреса всех приложений и
адреса их экземпляров. Eureka от Netflix выступает в качестве службы Discovery. Все сервисы обращаются к сервису
Discovery и регистрируются там. Служба Discovery будет знать, что у нас есть такой-то и такой-то номер и такие-то и
такие-то адреса.

То же самое произойдет с Gateway, он также свяжется с Config, чтобы получить свою конфигурацию .yml. И он также
зарегистрируется в Discovery.

Также есть балансировщик нагрузки (который трудно отобразить на этой диаграмме). Он будет участвовать в балансировке
REST-запросов.

Если у нас будет несколько сервисов Account (несколько экземпляров), то прежде чем сервис Gateway отправит запрос на
экземпляр 1 или 2, балансировщик нагрузки поймет, какой экземпляр менее загружен, и отправит запрос, который пришел на
Gateway.

То же самое происходит и с сервисом Deposit.

RabbitMQ как брокер сообщений будет очень удобен для асинхронной отправки сообщений / уведомлений.

### Архитектура сущностей БД

Далее рассмотрим основные сущности, которые будут использоваться, и их взаимосвязи друг с другом.

<p align="center">
  <img src="https://i.ibb.co/cQ4CBfj/Entities-Architecture.png" width="800">
</p>

В таблице сервиса Account будет первичный ключ - это "accountId", внутри таблицы также будут другие строки (см. рисунок
выше). Дополнительная таблица также будет создана для связи "account" и "bill". Здесь я использую генерацию схемы с
помощью JPA (не очень часто используется).

"billId" находится в другой базе данных - Bill service DB, и этот "billId" является первичным ключом для таблицы Bill.

Существует также БД Deposit service DB. Первичным ключом является "depositId". В этой таблице "bill_id" является внешним
ключом к другой базе данных (т.е. к тому, на какой счет был сделан депозит). Также в таблице Bill service DB есть еще
один внешний ключ между базами данных - это "account_id" (поле в сущности Bill), который является первичным ключом в
таблице Account таблицы в базе данных Account service DB.

### Функциональные сервисы

Данный проект "Банковская система" был разложен на 4 основных микросервиса. Все они представляют собой независимо
развертываемые приложения, организованные вокруг определенных бизнес-доменов.

#### Account service

Содержит общую логику пользовательского ввода и проверку: статьи доходов/расходов, сбережения и настройки счета.

| HTTP METHOD | PATH | USAGE |
| -----------| ------ | ------ |
| GET | /{accountId} | Account getting by id | 
| POST | / | Account creation |
| PUT | /{accountId} | Account updation |
| DELETE | /{accountId} | Account deletion |

### Привер JSON для Account Service

##### Создание аккаунта :

```sh
{
    "name": "Name",
    "email": "Email",
    "phone": "Phone",
    "bills": [ 1 ]
}
```

#### Bill Service

Создание счета для определенного аккаунта

| HTTP METHOD | PATH | USAGE |
| -----------| ------ | ------ |
| GET | /{billId} | Bill getting by id | 
| POST | / | Bill creation |
| PUT | /{billId} | Bill updation |
| DELETE | /{billId} | Bill deletion |

### Пример JSON для Bill Service

##### Создание счета :

```sh
{
    "accountId": 1,
    "amount": 5000,
    "overdraftEnabled": "true"
}
```

#### Deposit Service

Вносит депозит, обращаясь с запросом в Account service и в Bill service

| HTTP METHOD | PATH | USAGE |
| -----------| ------ | ------ |
| GET | /deposits | Deposit getting | 

Он включает в себя несколько запросов:

##### Account Service Client

| HTTP METHOD | PATH | USAGE |
| -----------| ------ | ------ |
| GET | /accounts/{accountId} | Account getting by id | 

##### Bill Response DTO

| HTTP METHOD | PATH | USAGE |
| -----------| ------ | ------ |
| GET | /bills/{billId} | Bill getting by id | 
| PUT | /bills/{billId} | Bill updation by id | 
| GET | /account/{accountId} | Bills getting by account id |  

### Пример JSON для Deposit Service

##### Занесение депозита :

```sh
{
    "billId": 1,
    "amount": 3000
} 
```

#### Notification Service

Этот сервис отвечает за уведомления. Используя класс SimpleMailMessage, можно создать некоторое уведомление о депозите.

### Вспомогательные сервисы

В распределенных системах существует множество общих паттернов, которые могут нам помочь заставить работать описанные
основные сервисы. Spring cloud предоставляет мощные инструменты, которые улучшают поведение Spring Boot приложений для
реализации этих паттернов.

#### Config Service

Spring Cloud Config - централизованная служба конфигурации для распределенных систем. Это единое место для хранения
конфигураций других сервисов.

Просто создайте приложение Spring Boot с зависимостью `spring-cloud-starter-config, остальное сделает автоконфигурация.

Теперь вам не нужны никакие встроенные свойства в вашем приложении. Просто предоставьте `bootstrap.yml` :

```yml
spring:
  cloud:
    config:
      
      
      
      
      
      
      server:
        native:
          search-locations: classpath:/services
  profiles:
    active: native
  security:
    user:
      password: admin

server:
  port: 8001
```

#### API Gateway

Теоретически, клиент может делать запросы к каждому из микросервисов напрямую. Но очевидно, что при таком варианте есть
свои сложности и ограничения, например, необходимость знать адреса всех конечных точек, выполнять http-запрос для каждой
части информации отдельно, объединять результат на стороне клиента. Другая проблема - недружественные веб-протоколы,
которые могут использоваться на бэкенде.

Обычно лучшим подходом является использование API Gateway. Это единая точка входа в систему, используемая для обработки
запросов путем их маршрутизации в соответствующую внутреннюю службу или путем вызова нескольких внутренних служб и
объединения результатов. Также он может использоваться для аутентификации, стресс- и канального тестирования, миграции
сервисов, обработки статических ответов, активного управления трафиком.

В этом проекте использую реализацию Netflix - Zuul.

```yml
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 20000

ribbon:
  ReadTimeout: 20000
  ConnectTimeout: 20000

zuul:
  ignoredServices: '*'
  host:
    connect-timeout-millis: 20000
    socket-timeout-millis: 20000

  routes:
    account-service:
      path: /accounts/**
      serviceId: account-service
      stripPrefix: false

    bill-service:
      path: /bills/**
      serviceId: bill-service
      stripPrefix: false

    deposit-service:
      path: /deposits/**
      serviceId: deposit-service
      stripPrefix: false

server:
  port: 8989
```

#### Discovery Service

Другим широко известным архитектурным шаблоном является Discovery Service. Он позволяет автоматически определять
местоположение в сети для экземпляров сервисов, которые могут иметь динамически назначаемые адреса из-за
автомасштабирования, сбоев и обновлений.

Ключевой частью обнаружения сервисов является реестр. В этом проекте я использую Netflix Eureka. Eureka - хороший пример
модели обнаружения на стороне клиента, когда клиент отвечает за определение местоположения доступных экземпляров
сервиса (с помощью сервера реестра)
и распределение нагрузки между ними.

С помощью Spring Boot вы можете легко создать реестр Eureka с зависимостью `spring-cloud-starter-eureka-server`,
аннотацией `@EnableEurekaServer` и простыми свойствами конфигурации.

Поддержка клиентов включена с помощью аннотации `@EnableDiscoveryClient` в `bootstrap.yml` с именем приложения:

```yml
spring:
  application:
    name: registry
  cloud:
    config:
      uri: http://config-service:8001
      fail-fast: true
      password: admin
      username: user

eureka:
  instance:
    preferIpAddress: true
  client:
    register-with-eureka: false
    fetch-registry: false
    server:
      waitTimeInMsWhenSyncEmpty: 0
  server:
    peer-node-read-timeout-ms: 100000
```

Кроме того, Eureka предоставляет простой интерфейс, где можно отслеживать запущенные сервисы и количество доступных
экземпляров: `http://localhost:8761`

#### Load balancer, Circuit breaker and Http client

Netflix OSS предоставляет еще один замечательный набор инструментов.

##### Ribbon

Ribbon - это балансировщик нагрузки на стороне клиента, который дает вам большой контроль над поведением HTTP и TCP
клиентов. По сравнению с традиционным балансировщиком нагрузки, нет необходимости в дополнительном переходах для каждого
вызова - вы можете напрямую связаться с нужной службой.

Из коробки он изначально интегрируется с Spring Cloud и Service Discovery. Eureka Client предоставляет динамический
список доступных серверов, чтобы Ribbon мог балансировать между ними.

##### Hystrix

Hystrix - это реализация шаблона Circuit Breaker, который дает контроль над задержкой и сбоями из-за зависимостей, к
которым осуществляется доступ по сети. Основная идея заключается в том, чтобы остановить каскадные сбои в распределенной
среде с большим количеством микросервисов. Это помогает быстро отключаться и восстанавливаться как можно скорее - важные
аспекты отказоустойчивых систем, которые самовосстанавливаются.

Помимо управления автоматическим выключением, с помощью Hystrix вы можете добавить резервный метод, который будет
вызываться для получения значения по умолчанию в случае сбоя основной команды.

Более того, Hystrix генерирует показатели результатов выполнения и задержки для каждой команды, которые мы можем
использовать для мониторинга поведения системы.

##### Feign

Feign - это декларативный Http-клиент, который легко интегрируется с Ribbon и Hystrix. На самом деле, с
одной зависимостью `spring-cloud-starter-feign` и аннотацией `@EnableFeignClients` у вас есть полный набор балансировщика нагрузки,
автоматический выключатель и Http-клиент с разумной готовой к работе конфигурацией по умолчанию.

### Как этим управлять?

Имейте в виду, что вы собираетесь запустить 7 приложений Spring Boot, 3 базы данных и RabbitMQ. Убедитесь, что у вас
есть "6 Гб" памяти, доступной для Docker. Однако вы всегда можете запустить только жизненно важные службы: шлюз, реестр, конфигурацию,
службу учетных записей и службу выставления счетов.

После настройки всех конфигураций вы обязательно должны выполнить сборку gradle.

Чтобы создать образ docker с использованием файла dockerfile для каждой службы, команда docker build, например, для
Account service поможет нам: "docker run -t account-service ."
(где точка - это каталог, в котором находится файл docker).

Чтобы запустить образ docker, вам необходимо использовать команду docker run для каждой службы,
например: `docker run -p 8081: учетная запись 8081-служба: последняя версия`
(где `последняя версия` - это самая последняя версия образа).

Docker-compose настраивается в файле .yml.

В этом проекте я использовал скрипт bash в файлах docker каждой службы
(для порядка запуска контейнеров).

Образы для каждого сервиса создаются с помощью команды "docker-compose build".

Непосредственный запуск выполняется командой `docker-compose up`.

### До запуска

- Установите Docker и Docker Compose.
- Запуск баз данных
- Запустите RabbitMQ в Docker
- Убедитесь, что вы создали проект

### Important endpoints

- config-service port 8001
- registry-service port 8761
- gateway port 8989
- acount-service port 8081
- deposit-serivce port 9999
- bill-service port 8082
- notification-service port 9999

### Notes

- Для запуска всех приложений Spring Boot требуется уже запущенный конфигурационный сервер. Но мы можем запускать все контейнеры
  одновременно из-за опции docker-compose `depends_on`.
- Каждый микросервис имеет свою собственную базу данных, поэтому нет способа обойти API и получить прямой доступ к данным о постоянстве.
